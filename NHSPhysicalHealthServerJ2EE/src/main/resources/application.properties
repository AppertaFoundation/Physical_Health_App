# example backend service
apperta.backend.url                           = http://localhost:8090

# Because the client and server are both hosted in the same app, this configuration
# is used to configure the client id and secret used by both
#
# The below config shows how they can be overridden. The password can be encyrpted
# using jcrypt. For the example the jcrypt master password is 'MasterJasyptPassword'
#apperta.cms.auth.client.clientId              = AppertaCms
#apperta.cms.auth.client.clientSecret          = secret
apperta.cms.auth.client.accessTokenUri        = http://localhost:8080/oauth/token
apperta.cms.auth.client.userAuthorizationUri  = http://localhost:8080/oauth/authorize

apperta.cms.auth.server.redirectUri           = http://localhost:8080/cms/login
apperta.cms.auth.server.userInfoServiceUri    = http://localhost:8080/iam/user/me

# every 30 minutes
apperta.cms.tar.rebuild.schedule.cron         = 0 0/30 * * * *
apperta.cms.tar.local.file                    = ./target/cms.tar.gz
apperta.cms.cache.duration.until.refresh      = P2D
apperta.cms.cache.duration.until.expiry       = P7D
apperta.cms.nhsapi.conditions.baseurl         = https://api.nhs.uk/conditions
apperta.cms.nhsapi.livewell.baseurl           = https://api.nhs.uk/live-well
apperta.cms.nhsapi.subscription.key           = invalid-value

apperta.cms.link.prefix                       = https://www.nhs.uk

apperta.email.from                            = noreply@localhost

# every 5 seconds
apperta.notifications.schedule.cron           = */5 * * * * *

apperta.password.reset.validity.duration      = PT30M

apperta.ui.url                                = http://localhost:8080

apperta.ehr.baseurl                           = https://cdr.code4health.org
apperta.ehr.connector                         = MarandFlat

apperta.ehrdemographics.baseurl               = https://cdr.code4health.org
apperta.ehrdemographics.connector             = MarandDemographics

# // TODO: encrypt
apperta.ehr.user.username                     = 0269bd31-0d37-4d74-b3d4-5a302605d980
apperta.ehr.user.token                        = $2a$10$619ki
apperta.ehr.healthcheck.schedule.cron         = 0 */5 * * * *

apperta.rest.connectiontimeout                = PT30S
apperta.rest.readtimeout                      = PT30S

# Default client username/password are defined in code (so we can
# warn if they're not overridden).
#
# Because the client and server are both hosted in the same app, this configuration
# is used to configure keys/passwords for both
#
# The below config shows how they can be overridden. The password can be encyrpted
# using jcrypt. For the example the jcrypt master password is 'MasterJasyptPassword'
#apperta.oauth.client.primaryEntityName       = my-trusted-client
#apperta.oauth.client.password                = ENC(Lw++P+MfcmFlymWQpfVJNw==)
#apperta.oauth.jwt.signing.key                = 123456789
apperta.oauth.token.access.validity.duration  = PT30M
apperta.oauth.token.refresh.validity.duration = PT2H

apperta.corsconfig.origins                    = http://localhost:3000,http://www.example.com 

apperta.patient.committer.name                = Patient
apperta.patient.committer.number              = 1

apperta.query.pagesize                        = 50

# This configures where swagger will find the authorization server for trying calls
apperta.swagger.config.authserver              = http://www.example.com


# JDBC Token Store produces logs at INFO level that on first glance appear
# to suggest there is a problem, but are actually benign
#
# "Failed to find access token for token d83452c7-d5b5-41f2-b03c-b9a31ac8d586"
#
# This is part of the OAuth token generation logic, because check to see if
# if the token already exists before using it, which produces the above log
# To avoid confusion, we've changed the log level to WARN for this class
# See https://github.com/spring-projects/spring-security-oauth/issues/788
logging.level.org.springframework.security.oauth2.provider.token.store.JdbcTokenStore = WARN

server.port                                   = 8080

spring.application.name                       = Apperta

# When using H2 spring's default naming strategy adds underscores between words in Table Names.
# This disables this behaviour
spring.jpa.hibernate.naming.physical-strategy = org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

# Will error if our Database Schema after applying Flyway Scripts
# does not reflect the JPA Model
spring.jpa.hibernate.ddl-auto                 = validate

# Removes a confusing but benign stack trace that appears on startup when using Postgres
# See https://github.com/spring-projects/spring-boot/issues/12007
# and https://hibernate.atlassian.net/browse/HHH-12368
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true

# Ensure we store all date/times as UTC in the database
# this is complemented by configuration in DateTimeConfig
spring.jpa.properties.hibernate.jdbc.time_zone = UTC

# Stops a warning appearing on startup regarding open in view being enabled
# Open in view is only relevant for web front ends
spring.jpa.open-in-view                       = false

spring.mail.host                              = localhost
spring.mail.port                              = 1025
spring.mail.properties.mail.smtp.auth         = false
spring.profiles.active                        = production

management.endpoint.health.show-details       = when-authorized
management.endpoint.health.roles              = ROLE_TRUSTED_CLIENT
